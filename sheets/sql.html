<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Aide-mémoire SQL : workflows pratiques pour requêtes, jointures, agrégations et manipulation de bases de données.">
    <title>SQL Mémento - IT Cheatsheets</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/styles.css">
</head>
<body class="dark-theme text-slate-200">

    <header class="bg-slate-900/50 border-b border-white/5 py-8 px-4 relative overflow-hidden header-glow">
        <div class="max-w-4xl mx-auto relative z-10">
            <div class="flex items-center justify-between mb-4">
                <a href="../index.html" class="nav-back inline-flex items-center text-slate-400 hover:text-sky-400 transition">
                    <i class="fas fa-arrow-left mr-2"></i>Retour
                </a>
                <a href="../index.html" class="inline-flex items-center text-slate-400 hover:text-sky-400 transition">
                    <i class="fas fa-home mr-2"></i>Accueil
                </a>
            </div>
            <div class="text-center">
                <div class="inline-flex items-center justify-center w-16 h-16 rounded-xl bg-slate-500/20 mb-4 icon-glow">
                    <i class="fas fa-database text-3xl text-slate-300"></i>
                </div>
                <h1 class="text-3xl font-bold mb-2 gradient-text">SQL Mémento</h1>
                <p class="text-slate-400">Workflows pratiques pour bases de données relationnelles</p>
            </div>
        </div>
    </header>

    <main class="max-w-4xl mx-auto p-4 relative z-10">
        <div class="mb-8 relative">
            <input type="text" id="searchInput" placeholder="Rechercher un workflow..."
                   class="search-dark w-full p-4 pl-12 rounded-lg outline-none transition">
            <i class="fas fa-search absolute left-4 top-1/2 transform -translate-y-1/2 text-slate-500"></i>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6" id="categoriesGrid"></div>
    </main>

    <div id="detailModal" class="fixed inset-0 bg-black/70 hidden items-center justify-center z-50 p-4 modal-overlay" onclick="closeModal(event)">
        <div class="modal-content-dark rounded-xl max-w-2xl w-full max-h-[90vh] overflow-y-auto shadow-2xl modal-content" onclick="event.stopPropagation()">
            <div id="modalContent"></div>
        </div>
    </div>

    <footer class="border-t border-white/5 text-center text-slate-500 py-8 text-sm relative z-10">
        <p>© 2026 - Dr FENOHASINA Toto Jean Felicien</p>
    </footer>

    <script>
        const cheatsheetData = [
            {
                id: 'extraire',
                title: 'Extraire des Données',
                icon: 'fa-download',
                color: 'border-l-4 border-blue-500',
                commands: [
                    {
                        cmd: 'Sélectionner toutes les données',
                        desc: 'SELECT * FROM table avec LIMIT',
                        details: {
                            explanation: 'Récupère toutes les colonnes d\'une table. L\'astérisque (*) signifie "toutes les colonnes". Utilisez LIMIT pour limiter les résultats.',
                            syntax: 'SELECT * FROM table [LIMIT n]',
                            options: [
                                { flag: '*', desc: 'Sélectionne toutes les colonnes' },
                                { flag: 'LIMIT n', desc: 'Limite à n lignes' },
                                { flag: 'TOP n', desc: 'SQL Server : limite à n lignes' }
                            ],
                            examples: [
                                { code: 'SELECT * FROM clients', desc: 'Toutes les données clients' },
                                { code: 'SELECT * FROM clients LIMIT 10', desc: 'Les 10 premières lignes' },
                                { code: 'SELECT TOP 10 * FROM clients', desc: 'SQL Server : 10 premières lignes' }
                            ],
                            tips: ['Évitez SELECT * en production, spécifiez les colonnes', 'Toujours utiliser LIMIT pour les grandes tables'],
                            warnings: ['SELECT * peut être très lent sur de grandes tables']
                        }
                    },
                    {
                        cmd: 'Choisir des colonnes spécifiques',
                        desc: 'SELECT col1, col2 et DISTINCT',
                        details: {
                            explanation: 'Récupère uniquement les colonnes nécessaires. Plus efficace que SELECT *. DISTINCT élimine les doublons.',
                            syntax: 'SELECT [DISTINCT] col1, col2 FROM table',
                            options: [
                                { flag: 'DISTINCT', desc: 'Supprime les doublons du résultat' },
                                { flag: 'ALL', desc: 'Garde tous les résultats (défaut)' }
                            ],
                            examples: [
                                { code: 'SELECT nom, email FROM clients', desc: 'Nom et email uniquement' },
                                { code: 'SELECT DISTINCT ville FROM clients', desc: 'Villes uniques (sans doublons)' },
                                { code: 'SELECT DISTINCT categorie, statut FROM produits', desc: 'Combinaisons uniques' }
                            ],
                            tips: ['DISTINCT s\'applique à toutes les colonnes sélectionnées'],
                            warnings: ['DISTINCT peut être coûteux en performance sur de gros volumes']
                        }
                    },
                    {
                        cmd: 'Renommer des colonnes',
                        desc: 'AS pour alias de colonnes et tables',
                        details: {
                            explanation: 'Donne un nom temporaire (alias) à une colonne, une expression ou une table pour plus de lisibilité.',
                            syntax: 'SELECT colonne AS alias FROM table AS t',
                            options: [
                                { flag: 'AS', desc: 'Mot-clé pour définir l\'alias (optionnel)' },
                                { flag: 'Guillemets', desc: 'Pour alias avec espaces : "Mon Alias"' }
                            ],
                            examples: [
                                { code: 'SELECT nom AS client_name FROM clients', desc: 'Renommer une colonne' },
                                { code: 'SELECT nom, prix * 1.2 AS prix_ttc FROM produits', desc: 'Alias sur expression' },
                                { code: 'SELECT c.nom, o.date\nFROM clients c\nJOIN orders o ON c.id = o.client_id', desc: 'Alias de tables pour les jointures' }
                            ],
                            tips: ['Les alias de tables sont essentiels pour les jointures', 'AS est optionnel mais améliore la lisibilité'],
                            warnings: []
                        }
                    },
                    {
                        cmd: 'Transformer des valeurs',
                        desc: 'CASE WHEN pour conditions',
                        details: {
                            explanation: 'Crée des colonnes calculées avec des conditions. Équivalent d\'un if/else dans SQL.',
                            syntax: 'CASE WHEN condition THEN valeur [ELSE valeur] END',
                            options: [
                                { flag: 'WHEN', desc: 'Condition à évaluer' },
                                { flag: 'THEN', desc: 'Valeur si condition vraie' },
                                { flag: 'ELSE', desc: 'Valeur par défaut (optionnel)' },
                                { flag: 'END', desc: 'Fin du CASE' }
                            ],
                            examples: [
                                { code: 'SELECT nom,\n  CASE WHEN age >= 18 THEN \'Adulte\' ELSE \'Mineur\' END AS statut\nFROM personnes', desc: 'Catégorisation simple' },
                                { code: 'SELECT nom,\n  CASE\n    WHEN note >= 16 THEN \'Très bien\'\n    WHEN note >= 12 THEN \'Bien\'\n    WHEN note >= 10 THEN \'Passable\'\n    ELSE \'Insuffisant\'\n  END AS mention\nFROM etudiants', desc: 'Plusieurs conditions' },
                                { code: 'SELECT \n  SUM(CASE WHEN statut = \'actif\' THEN 1 ELSE 0 END) AS nb_actifs,\n  SUM(CASE WHEN statut = \'inactif\' THEN 1 ELSE 0 END) AS nb_inactifs\nFROM clients', desc: 'Comptage conditionnel' }
                            ],
                            tips: ['CASE peut être utilisé dans SELECT, WHERE, ORDER BY, etc.', 'Toujours terminer par END'],
                            warnings: ['Sans ELSE, les cas non couverts retournent NULL']
                        }
                    },
                    {
                        cmd: 'Gérer les valeurs manquantes',
                        desc: 'COALESCE, IFNULL, NULLIF',
                        details: {
                            explanation: 'Fonctions pour gérer les valeurs NULL : remplacer, détecter ou créer des NULL.',
                            syntax: 'COALESCE(val1, val2, ...) / IFNULL(val, default)',
                            options: [
                                { flag: 'COALESCE', desc: 'Retourne la première valeur non NULL' },
                                { flag: 'IFNULL', desc: 'MySQL : remplace NULL par défaut' },
                                { flag: 'ISNULL', desc: 'SQL Server : remplace NULL' },
                                { flag: 'NULLIF', desc: 'Retourne NULL si val1 = val2' }
                            ],
                            examples: [
                                { code: 'SELECT nom, COALESCE(telephone, email, \'Non renseigné\') AS contact\nFROM clients', desc: 'Premier contact disponible' },
                                { code: 'SELECT nom, IFNULL(note, 0) AS note\nFROM etudiants', desc: 'MySQL : remplacer NULL par 0' },
                                { code: 'SELECT prix / NULLIF(quantite, 0) AS prix_unitaire\nFROM ventes', desc: 'Éviter division par zéro' }
                            ],
                            tips: ['COALESCE est standard SQL et fonctionne partout', 'NULLIF est utile pour éviter les divisions par zéro'],
                            warnings: ['IFNULL est spécifique à MySQL, préférez COALESCE']
                        }
                    }
                ]
            },
            {
                id: 'filtrer',
                title: 'Filtrer et Rechercher',
                icon: 'fa-filter',
                color: 'border-l-4 border-green-500',
                commands: [
                    {
                        cmd: 'Filtrer avec des conditions simples',
                        desc: 'WHERE avec =, <>, >, BETWEEN, IN',
                        details: {
                            explanation: 'WHERE filtre les lignes selon des conditions. Les opérateurs de comparaison permettent de sélectionner précisément les données.',
                            syntax: 'SELECT ... FROM table WHERE condition',
                            options: [
                                { flag: '=, <>, !=', desc: 'Égal, différent' },
                                { flag: '>, <, >=, <=', desc: 'Comparaisons numériques' },
                                { flag: 'BETWEEN a AND b', desc: 'Valeur dans un intervalle (inclus)' },
                                { flag: 'IN (v1, v2, ...)', desc: 'Valeur dans une liste' }
                            ],
                            examples: [
                                { code: 'SELECT * FROM clients WHERE age >= 18', desc: 'Clients majeurs' },
                                { code: 'SELECT * FROM produits WHERE prix BETWEEN 10 AND 50', desc: 'Prix entre 10 et 50' },
                                { code: 'SELECT * FROM commandes WHERE statut IN (\'envoyé\', \'livré\')', desc: 'Statuts spécifiques' },
                                { code: 'SELECT * FROM clients WHERE ville <> \'Paris\'', desc: 'Hors Paris' }
                            ],
                            tips: ['BETWEEN inclut les bornes', 'IN est plus lisible que plusieurs OR'],
                            warnings: ['<> est standard SQL, != fonctionne mais n\'est pas standard']
                        }
                    },
                    {
                        cmd: 'Rechercher par motif de texte',
                        desc: 'LIKE avec % et _ pour patterns',
                        details: {
                            explanation: 'LIKE permet de rechercher des motifs dans les chaînes de caractères avec des jokers.',
                            syntax: 'WHERE colonne LIKE \'pattern\'',
                            options: [
                                { flag: '%', desc: 'Remplace 0 ou plusieurs caractères' },
                                { flag: '_', desc: 'Remplace exactement 1 caractère' },
                                { flag: 'ILIKE', desc: 'PostgreSQL : LIKE insensible à la casse' },
                                { flag: 'ESCAPE', desc: 'Caractère d\'échappement pour % et _' }
                            ],
                            examples: [
                                { code: 'SELECT * FROM clients WHERE nom LIKE \'Mar%\'', desc: 'Noms commençant par Mar' },
                                { code: 'SELECT * FROM clients WHERE email LIKE \'%@gmail.com\'', desc: 'Emails Gmail' },
                                { code: 'SELECT * FROM produits WHERE code LIKE \'A__\'', desc: 'Code A suivi de 2 caractères' },
                                { code: 'SELECT * FROM clients WHERE nom ILIKE \'%dupont%\'', desc: 'PostgreSQL : recherche insensible à la casse' }
                            ],
                            tips: ['%texte% = contient "texte"', 'Pour chercher littéralement % ou _, utilisez ESCAPE'],
                            warnings: ['LIKE avec % au début est lent (pas d\'utilisation d\'index)']
                        }
                    },
                    {
                        cmd: 'Trouver les valeurs NULL',
                        desc: 'IS NULL et IS NOT NULL',
                        details: {
                            explanation: 'NULL représente l\'absence de valeur. On ne peut pas utiliser = pour tester NULL, il faut IS NULL.',
                            syntax: 'WHERE colonne IS [NOT] NULL',
                            options: [
                                { flag: 'IS NULL', desc: 'Teste si la valeur est NULL' },
                                { flag: 'IS NOT NULL', desc: 'Teste si la valeur existe' }
                            ],
                            examples: [
                                { code: 'SELECT * FROM clients WHERE telephone IS NULL', desc: 'Clients sans téléphone' },
                                { code: 'SELECT * FROM clients WHERE email IS NOT NULL', desc: 'Clients avec email' },
                                { code: 'SELECT COUNT(*) FROM produits WHERE description IS NULL', desc: 'Compter les produits sans description' }
                            ],
                            tips: ['Toujours utiliser IS NULL, jamais = NULL', 'NULL != NULL est vrai (comportement SQL)'],
                            warnings: ['= NULL ne fonctionne JAMAIS, utilisez IS NULL']
                        }
                    },
                    {
                        cmd: 'Combiner plusieurs conditions',
                        desc: 'AND, OR, NOT et parenthèses',
                        details: {
                            explanation: 'Les opérateurs logiques combinent plusieurs conditions. Les parenthèses contrôlent la priorité.',
                            syntax: 'WHERE condition1 AND/OR condition2',
                            options: [
                                { flag: 'AND', desc: 'Les deux conditions doivent être vraies' },
                                { flag: 'OR', desc: 'Au moins une condition vraie' },
                                { flag: 'NOT', desc: 'Inverse la condition' },
                                { flag: '()', desc: 'Parenthèses pour priorité' }
                            ],
                            examples: [
                                { code: 'SELECT * FROM clients\nWHERE age >= 18 AND ville = \'Paris\'', desc: 'Adultes parisiens' },
                                { code: 'SELECT * FROM produits\nWHERE categorie = \'Tech\' OR prix > 100', desc: 'Tech ou prix > 100' },
                                { code: 'SELECT * FROM clients\nWHERE ville = \'Paris\' AND (age < 25 OR vip = true)', desc: 'Parisiens jeunes ou VIP' },
                                { code: 'SELECT * FROM produits\nWHERE NOT categorie = \'Obsolète\'', desc: 'Exclure une catégorie' }
                            ],
                            tips: ['AND a priorité sur OR, utilisez des parenthèses pour clarifier', 'NOT IN et NOT LIKE existent aussi'],
                            warnings: ['Sans parenthèses, AND s\'exécute avant OR']
                        }
                    },
                    {
                        cmd: 'Vérifier l\'existence dans une autre table',
                        desc: 'EXISTS et NOT EXISTS',
                        details: {
                            explanation: 'EXISTS teste si une sous-requête retourne au moins une ligne. Plus efficace que IN pour les grandes tables.',
                            syntax: 'WHERE [NOT] EXISTS (sous-requête)',
                            options: [
                                { flag: 'EXISTS', desc: 'Vrai si la sous-requête retourne des lignes' },
                                { flag: 'NOT EXISTS', desc: 'Vrai si la sous-requête est vide' }
                            ],
                            examples: [
                                { code: 'SELECT * FROM clients c\nWHERE EXISTS (\n  SELECT 1 FROM commandes o\n  WHERE o.client_id = c.id\n)', desc: 'Clients avec au moins une commande' },
                                { code: 'SELECT * FROM clients c\nWHERE NOT EXISTS (\n  SELECT 1 FROM commandes o\n  WHERE o.client_id = c.id\n)', desc: 'Clients sans aucune commande' },
                                { code: 'SELECT * FROM produits p\nWHERE EXISTS (\n  SELECT 1 FROM ventes v\n  WHERE v.produit_id = p.id\n  AND v.date > \'2024-01-01\'\n)', desc: 'Produits vendus en 2024' }
                            ],
                            tips: ['EXISTS s\'arrête dès qu\'une ligne est trouvée (efficace)', 'SELECT 1 ou SELECT * dans EXISTS - pas de différence'],
                            warnings: ['EXISTS peut être plus performant que IN sur grandes tables']
                        }
                    }
                ]
            },
            {
                id: 'trier',
                title: 'Trier et Paginer',
                icon: 'fa-sort',
                color: 'border-l-4 border-cyan-500',
                commands: [
                    {
                        cmd: 'Trier les résultats',
                        desc: 'ORDER BY ASC/DESC multi-colonnes',
                        details: {
                            explanation: 'ORDER BY trie les résultats selon une ou plusieurs colonnes, en ordre croissant (ASC) ou décroissant (DESC).',
                            syntax: 'SELECT ... ORDER BY col1 [ASC|DESC], col2 [ASC|DESC]',
                            options: [
                                { flag: 'ASC', desc: 'Ordre croissant (défaut)' },
                                { flag: 'DESC', desc: 'Ordre décroissant' },
                                { flag: 'NULLS FIRST', desc: 'NULL en premier (PostgreSQL)' },
                                { flag: 'NULLS LAST', desc: 'NULL en dernier (PostgreSQL)' }
                            ],
                            examples: [
                                { code: 'SELECT * FROM clients ORDER BY nom ASC', desc: 'Tri alphabétique' },
                                { code: 'SELECT * FROM produits ORDER BY prix DESC', desc: 'Du plus cher au moins cher' },
                                { code: 'SELECT * FROM ventes\nORDER BY date DESC, montant DESC', desc: 'Tri multi-colonnes' },
                                { code: 'SELECT * FROM clients\nORDER BY ville ASC, nom ASC', desc: 'Par ville puis par nom' }
                            ],
                            tips: ['ASC est le défaut, on peut l\'omettre', 'On peut trier par numéro de colonne : ORDER BY 1, 2'],
                            warnings: ['Le tri est coûteux sur de grandes tables sans index']
                        }
                    },
                    {
                        cmd: 'Limiter le nombre de résultats',
                        desc: 'LIMIT, TOP, FETCH FIRST',
                        details: {
                            explanation: 'Limite le nombre de lignes retournées. La syntaxe varie selon le SGBD.',
                            syntax: 'LIMIT n / TOP n / FETCH FIRST n ROWS ONLY',
                            options: [
                                { flag: 'LIMIT n', desc: 'MySQL, PostgreSQL, SQLite' },
                                { flag: 'TOP n', desc: 'SQL Server (après SELECT)' },
                                { flag: 'FETCH FIRST n ROWS ONLY', desc: 'Standard SQL (après ORDER BY)' },
                                { flag: 'ROWNUM <= n', desc: 'Oracle (ancienne syntaxe)' }
                            ],
                            examples: [
                                { code: 'SELECT * FROM clients\nORDER BY date_inscription DESC\nLIMIT 10', desc: 'MySQL/PostgreSQL : 10 derniers inscrits' },
                                { code: 'SELECT TOP 10 * FROM clients\nORDER BY date_inscription DESC', desc: 'SQL Server : 10 derniers inscrits' },
                                { code: 'SELECT * FROM clients\nORDER BY date_inscription DESC\nFETCH FIRST 10 ROWS ONLY', desc: 'Standard SQL' }
                            ],
                            tips: ['Toujours combiner avec ORDER BY pour des résultats prévisibles', 'LIMIT est le plus répandu'],
                            warnings: ['Sans ORDER BY, les résultats sont imprévisibles']
                        }
                    },
                    {
                        cmd: 'Paginer les résultats',
                        desc: 'OFFSET pour la pagination',
                        details: {
                            explanation: 'OFFSET saute un nombre de lignes, combiné avec LIMIT pour paginer les résultats.',
                            syntax: 'LIMIT n OFFSET m / OFFSET m ROWS FETCH NEXT n ROWS ONLY',
                            options: [
                                { flag: 'OFFSET m', desc: 'Saute les m premières lignes' },
                                { flag: 'LIMIT n OFFSET m', desc: 'MySQL, PostgreSQL, SQLite' },
                                { flag: 'OFFSET m ROWS FETCH NEXT n ROWS ONLY', desc: 'Standard SQL' }
                            ],
                            examples: [
                                { code: '-- Page 1 (items 1-10)\nSELECT * FROM produits\nORDER BY id\nLIMIT 10 OFFSET 0', desc: 'Première page' },
                                { code: '-- Page 2 (items 11-20)\nSELECT * FROM produits\nORDER BY id\nLIMIT 10 OFFSET 10', desc: 'Deuxième page' },
                                { code: '-- Page n (générique)\n-- OFFSET = (page - 1) * items_par_page\nSELECT * FROM produits\nORDER BY id\nLIMIT 10 OFFSET 20', desc: 'Troisième page' }
                            ],
                            tips: ['Formule : OFFSET = (numéro_page - 1) × items_par_page', 'Pour de grandes tables, préférez la pagination par curseur (WHERE id > last_id)'],
                            warnings: ['OFFSET élevé = performances dégradées']
                        }
                    },
                    {
                        cmd: 'Obtenir le premier/dernier',
                        desc: 'ORDER BY + LIMIT 1',
                        details: {
                            explanation: 'Combine ORDER BY et LIMIT 1 pour obtenir la valeur minimale ou maximale d\'une colonne.',
                            syntax: 'SELECT ... ORDER BY col [ASC|DESC] LIMIT 1',
                            options: [
                                { flag: 'ORDER BY col ASC LIMIT 1', desc: 'Premier (minimum)' },
                                { flag: 'ORDER BY col DESC LIMIT 1', desc: 'Dernier (maximum)' }
                            ],
                            examples: [
                                { code: 'SELECT * FROM clients\nORDER BY date_inscription ASC\nLIMIT 1', desc: 'Premier client inscrit' },
                                { code: 'SELECT * FROM commandes\nORDER BY montant DESC\nLIMIT 1', desc: 'Commande la plus élevée' },
                                { code: 'SELECT * FROM produits\nWHERE categorie = \'Tech\'\nORDER BY prix DESC\nLIMIT 1', desc: 'Produit tech le plus cher' }
                            ],
                            tips: ['Plus efficace que MAX() si vous voulez toute la ligne', 'Utilisez un index sur la colonne triée'],
                            warnings: []
                        }
                    }
                ]
            },
            {
                id: 'combiner',
                title: 'Combiner des Tables',
                icon: 'fa-link',
                color: 'border-l-4 border-purple-500',
                commands: [
                    {
                        cmd: 'Joindre avec correspondance',
                        desc: 'INNER JOIN pour intersection',
                        details: {
                            explanation: 'INNER JOIN retourne uniquement les lignes qui ont une correspondance dans les deux tables.',
                            syntax: 'SELECT ... FROM table1 INNER JOIN table2 ON condition',
                            options: [
                                { flag: 'INNER JOIN', desc: 'Jointure interne (intersection)' },
                                { flag: 'JOIN', desc: 'Synonyme de INNER JOIN' },
                                { flag: 'ON', desc: 'Condition de jointure' },
                                { flag: 'USING(col)', desc: 'Si même nom de colonne' }
                            ],
                            examples: [
                                { code: 'SELECT c.nom, o.date, o.montant\nFROM clients c\nINNER JOIN commandes o ON c.id = o.client_id', desc: 'Clients avec leurs commandes' },
                                { code: 'SELECT p.nom, cat.nom AS categorie\nFROM produits p\nJOIN categories cat ON p.categorie_id = cat.id', desc: 'Produits avec catégorie' },
                                { code: 'SELECT e.nom, d.nom AS departement\nFROM employes e\nJOIN departements d USING(departement_id)', desc: 'Avec USING si même nom de colonne' }
                            ],
                            tips: ['Utilisez des alias de tables (c, o) pour plus de clarté', 'INNER JOIN est le type de jointure le plus courant'],
                            warnings: ['Les lignes sans correspondance sont exclues']
                        }
                    },
                    {
                        cmd: 'Garder toutes les lignes d\'une table',
                        desc: 'LEFT JOIN et RIGHT JOIN',
                        details: {
                            explanation: 'LEFT JOIN garde toutes les lignes de la table de gauche, même sans correspondance (NULL pour les colonnes de droite).',
                            syntax: 'SELECT ... FROM table1 LEFT JOIN table2 ON condition',
                            options: [
                                { flag: 'LEFT JOIN', desc: 'Garde toutes les lignes de la table de gauche' },
                                { flag: 'RIGHT JOIN', desc: 'Garde toutes les lignes de la table de droite' },
                                { flag: 'LEFT OUTER JOIN', desc: 'Synonyme de LEFT JOIN' }
                            ],
                            examples: [
                                { code: 'SELECT c.nom, o.date, o.montant\nFROM clients c\nLEFT JOIN commandes o ON c.id = o.client_id', desc: 'Tous les clients, avec ou sans commande' },
                                { code: 'SELECT c.nom, COUNT(o.id) AS nb_commandes\nFROM clients c\nLEFT JOIN commandes o ON c.id = o.client_id\nGROUP BY c.id, c.nom', desc: 'Nombre de commandes par client (0 si aucune)' },
                                { code: 'SELECT p.nom, v.quantite\nFROM produits p\nLEFT JOIN ventes v ON p.id = v.produit_id\nWHERE v.id IS NULL', desc: 'Produits jamais vendus' }
                            ],
                            tips: ['LEFT JOIN + WHERE IS NULL = lignes sans correspondance', 'RIGHT JOIN est rarement utilisé (on réécrit en LEFT JOIN)'],
                            warnings: ['Attention à l\'ordre des tables avec LEFT/RIGHT JOIN']
                        }
                    },
                    {
                        cmd: 'Garder toutes les lignes des deux tables',
                        desc: 'FULL OUTER JOIN',
                        details: {
                            explanation: 'FULL OUTER JOIN garde toutes les lignes des deux tables, avec NULL pour les non-correspondances.',
                            syntax: 'SELECT ... FROM table1 FULL OUTER JOIN table2 ON condition',
                            options: [
                                { flag: 'FULL OUTER JOIN', desc: 'Union des deux tables' },
                                { flag: 'FULL JOIN', desc: 'Synonyme' }
                            ],
                            examples: [
                                { code: 'SELECT c.nom, o.date\nFROM clients c\nFULL OUTER JOIN commandes o ON c.id = o.client_id', desc: 'Tous clients et toutes commandes' },
                                { code: 'SELECT e.nom AS employe, p.nom AS projet\nFROM employes e\nFULL OUTER JOIN projets p ON e.projet_id = p.id', desc: 'Employés et projets (tous)' }
                            ],
                            tips: ['Utile pour identifier les données manquantes des deux côtés', 'Peut être simulé avec UNION de deux LEFT JOIN'],
                            warnings: ['Non supporté par MySQL (utiliser UNION)', 'Peut générer beaucoup de NULL']
                        }
                    },
                    {
                        cmd: 'Générer toutes les combinaisons',
                        desc: 'CROSS JOIN pour produit cartésien',
                        details: {
                            explanation: 'CROSS JOIN combine chaque ligne de la première table avec chaque ligne de la seconde (produit cartésien).',
                            syntax: 'SELECT ... FROM table1 CROSS JOIN table2',
                            options: [
                                { flag: 'CROSS JOIN', desc: 'Produit cartésien explicite' },
                                { flag: 'FROM t1, t2', desc: 'Syntaxe implicite (éviter)' }
                            ],
                            examples: [
                                { code: 'SELECT c.nom AS couleur, t.nom AS taille\nFROM couleurs c\nCROSS JOIN tailles t', desc: 'Toutes combinaisons couleur-taille' },
                                { code: 'SELECT d.date, p.nom\nFROM dates d\nCROSS JOIN produits p', desc: 'Chaque produit pour chaque date' },
                                { code: 'SELECT a.valeur AS a, b.valeur AS b\nFROM chiffres a\nCROSS JOIN chiffres b\nWHERE a.valeur < b.valeur', desc: 'Toutes les paires ordonnées' }
                            ],
                            tips: ['Utile pour générer des combinaisons ou un calendrier', 'Nombre de lignes = lignes_t1 × lignes_t2'],
                            warnings: ['Peut générer un très grand nombre de lignes !', '100 × 100 = 10 000 lignes']
                        }
                    },
                    {
                        cmd: 'Joindre une table avec elle-même',
                        desc: 'Self JOIN pour hiérarchies',
                        details: {
                            explanation: 'Une self-join joint une table avec elle-même. Utile pour les hiérarchies (manager/employé) ou comparaisons.',
                            syntax: 'SELECT ... FROM table t1 JOIN table t2 ON condition',
                            options: [
                                { flag: 'Alias obligatoires', desc: 't1, t2 pour distinguer les deux instances' }
                            ],
                            examples: [
                                { code: 'SELECT e.nom AS employe, m.nom AS manager\nFROM employes e\nLEFT JOIN employes m ON e.manager_id = m.id', desc: 'Employés avec leur manager' },
                                { code: 'SELECT c1.nom, c2.nom AS client_meme_ville\nFROM clients c1\nJOIN clients c2 ON c1.ville = c2.ville\nWHERE c1.id < c2.id', desc: 'Paires de clients de même ville' },
                                { code: 'SELECT p1.nom, p2.nom AS produit_similaire\nFROM produits p1\nJOIN produits p2 ON p1.categorie_id = p2.categorie_id\nWHERE p1.id <> p2.id', desc: 'Produits de même catégorie' }
                            ],
                            tips: ['c1.id < c2.id évite les doublons (A,B et B,A)', 'LEFT JOIN pour inclure les éléments sans parent'],
                            warnings: ['Toujours utiliser des alias différents']
                        }
                    }
                ]
            },
            {
                id: 'agreger',
                title: 'Calculer des Statistiques',
                icon: 'fa-calculator',
                color: 'border-l-4 border-orange-500',
                commands: [
                    {
                        cmd: 'Compter des lignes',
                        desc: 'COUNT(*) et COUNT(DISTINCT)',
                        details: {
                            explanation: 'COUNT compte le nombre de lignes. COUNT(*) compte toutes les lignes, COUNT(col) ignore les NULL.',
                            syntax: 'SELECT COUNT(*) FROM table',
                            options: [
                                { flag: 'COUNT(*)', desc: 'Compte toutes les lignes' },
                                { flag: 'COUNT(col)', desc: 'Compte les valeurs non NULL' },
                                { flag: 'COUNT(DISTINCT col)', desc: 'Compte les valeurs uniques' }
                            ],
                            examples: [
                                { code: 'SELECT COUNT(*) FROM clients', desc: 'Nombre total de clients' },
                                { code: 'SELECT COUNT(email) FROM clients', desc: 'Clients avec email (non NULL)' },
                                { code: 'SELECT COUNT(DISTINCT ville) FROM clients', desc: 'Nombre de villes différentes' },
                                { code: 'SELECT categorie, COUNT(*) AS nb_produits\nFROM produits\nGROUP BY categorie', desc: 'Produits par catégorie' }
                            ],
                            tips: ['COUNT(*) est souvent plus rapide que COUNT(col)', 'COUNT(DISTINCT) peut être coûteux'],
                            warnings: ['COUNT(col) ignore les NULL']
                        }
                    },
                    {
                        cmd: 'Calculer somme et moyenne',
                        desc: 'SUM et AVG',
                        details: {
                            explanation: 'SUM calcule la somme, AVG calcule la moyenne des valeurs numériques.',
                            syntax: 'SELECT SUM(col), AVG(col) FROM table',
                            options: [
                                { flag: 'SUM(col)', desc: 'Somme des valeurs' },
                                { flag: 'AVG(col)', desc: 'Moyenne des valeurs' },
                                { flag: 'SUM(DISTINCT col)', desc: 'Somme des valeurs uniques' }
                            ],
                            examples: [
                                { code: 'SELECT SUM(montant) AS total_ventes\nFROM commandes', desc: 'Total des ventes' },
                                { code: 'SELECT AVG(prix) AS prix_moyen\nFROM produits', desc: 'Prix moyen des produits' },
                                { code: 'SELECT categorie,\n  SUM(quantite) AS total,\n  AVG(prix) AS prix_moyen\nFROM produits\nGROUP BY categorie', desc: 'Stats par catégorie' }
                            ],
                            tips: ['AVG ignore les NULL automatiquement', 'Pour inclure les NULL comme 0 : AVG(COALESCE(col, 0))'],
                            warnings: ['SUM et AVG sur des colonnes non numériques = erreur']
                        }
                    },
                    {
                        cmd: 'Trouver min et max',
                        desc: 'MIN et MAX',
                        details: {
                            explanation: 'MIN et MAX retournent la valeur minimale et maximale. Fonctionnent aussi sur les dates et textes.',
                            syntax: 'SELECT MIN(col), MAX(col) FROM table',
                            options: [
                                { flag: 'MIN(col)', desc: 'Valeur minimale' },
                                { flag: 'MAX(col)', desc: 'Valeur maximale' }
                            ],
                            examples: [
                                { code: 'SELECT MIN(prix), MAX(prix) FROM produits', desc: 'Prix min et max' },
                                { code: 'SELECT MIN(date_commande) AS premiere,\n       MAX(date_commande) AS derniere\nFROM commandes', desc: 'Première et dernière commande' },
                                { code: 'SELECT categorie,\n  MIN(prix) AS moins_cher,\n  MAX(prix) AS plus_cher\nFROM produits\nGROUP BY categorie', desc: 'Extremes par catégorie' }
                            ],
                            tips: ['MIN/MAX sur texte = ordre alphabétique', 'Pour obtenir la ligne complète, utilisez ORDER BY + LIMIT 1'],
                            warnings: []
                        }
                    },
                    {
                        cmd: 'Grouper par catégorie',
                        desc: 'GROUP BY pour agrégations',
                        details: {
                            explanation: 'GROUP BY regroupe les lignes par valeurs identiques pour calculer des agrégations par groupe.',
                            syntax: 'SELECT col, AGG() FROM table GROUP BY col',
                            options: [
                                { flag: 'GROUP BY col', desc: 'Groupe par une colonne' },
                                { flag: 'GROUP BY col1, col2', desc: 'Groupe par plusieurs colonnes' },
                                { flag: 'GROUP BY ROLLUP', desc: 'Ajoute des sous-totaux (PostgreSQL, Oracle)' }
                            ],
                            examples: [
                                { code: 'SELECT ville, COUNT(*) AS nb_clients\nFROM clients\nGROUP BY ville', desc: 'Clients par ville' },
                                { code: 'SELECT annee, mois, SUM(montant) AS total\nFROM ventes\nGROUP BY annee, mois\nORDER BY annee, mois', desc: 'Ventes par année et mois' },
                                { code: 'SELECT categorie, statut, COUNT(*) AS nb\nFROM produits\nGROUP BY categorie, statut', desc: 'Combinaisons catégorie/statut' }
                            ],
                            tips: ['Toutes les colonnes non agrégées doivent être dans GROUP BY', 'ORDER BY peut suivre GROUP BY'],
                            warnings: ['Erreur si une colonne SELECT n\'est ni agrégée ni dans GROUP BY']
                        }
                    },
                    {
                        cmd: 'Filtrer les groupes',
                        desc: 'HAVING pour conditions après agrégation',
                        details: {
                            explanation: 'HAVING filtre les groupes après agrégation (contrairement à WHERE qui filtre avant).',
                            syntax: 'SELECT ... GROUP BY col HAVING condition',
                            options: [
                                { flag: 'HAVING', desc: 'Filtre après GROUP BY' },
                                { flag: 'WHERE vs HAVING', desc: 'WHERE = avant, HAVING = après agrégation' }
                            ],
                            examples: [
                                { code: 'SELECT ville, COUNT(*) AS nb_clients\nFROM clients\nGROUP BY ville\nHAVING COUNT(*) >= 10', desc: 'Villes avec 10+ clients' },
                                { code: 'SELECT client_id, SUM(montant) AS total\nFROM commandes\nGROUP BY client_id\nHAVING SUM(montant) > 1000', desc: 'Clients avec plus de 1000€ de commandes' },
                                { code: 'SELECT categorie, AVG(prix) AS prix_moyen\nFROM produits\nWHERE actif = true\nGROUP BY categorie\nHAVING AVG(prix) > 50', desc: 'WHERE et HAVING combinés' }
                            ],
                            tips: ['WHERE filtre les lignes, HAVING filtre les groupes', 'On peut utiliser les deux dans la même requête'],
                            warnings: ['HAVING sans GROUP BY est possible mais rare']
                        }
                    }
                ]
            },
            {
                id: 'classer',
                title: 'Classer et Numéroter',
                icon: 'fa-medal',
                color: 'border-l-4 border-yellow-500',
                commands: [
                    {
                        cmd: 'Numéroter les lignes',
                        desc: 'ROW_NUMBER() OVER',
                        details: {
                            explanation: 'ROW_NUMBER() attribue un numéro séquentiel à chaque ligne dans une partition, selon l\'ordre spécifié.',
                            syntax: 'ROW_NUMBER() OVER ([PARTITION BY col] ORDER BY col)',
                            options: [
                                { flag: 'OVER()', desc: 'Définit la fenêtre de calcul' },
                                { flag: 'PARTITION BY', desc: 'Repart de 1 pour chaque groupe' },
                                { flag: 'ORDER BY', desc: 'Définit l\'ordre de numérotation' }
                            ],
                            examples: [
                                { code: 'SELECT nom, date_inscription,\n  ROW_NUMBER() OVER (ORDER BY date_inscription) AS rang\nFROM clients', desc: 'Numéroter par date d\'inscription' },
                                { code: 'SELECT categorie, nom, prix,\n  ROW_NUMBER() OVER (\n    PARTITION BY categorie\n    ORDER BY prix DESC\n  ) AS rang_categorie\nFROM produits', desc: 'Rang par catégorie' },
                                { code: 'WITH numbered AS (\n  SELECT *, ROW_NUMBER() OVER (ORDER BY id) AS rn\n  FROM clients\n)\nSELECT * FROM numbered WHERE rn BETWEEN 11 AND 20', desc: 'Pagination avec ROW_NUMBER' }
                            ],
                            tips: ['ROW_NUMBER donne toujours des numéros uniques', 'Utile pour la pagination ou sélectionner le premier de chaque groupe'],
                            warnings: ['Requiert ORDER BY dans OVER() pour des résultats prévisibles']
                        }
                    },
                    {
                        cmd: 'Calculer un classement',
                        desc: 'RANK() et DENSE_RANK()',
                        details: {
                            explanation: 'RANK et DENSE_RANK créent des classements. RANK saute des rangs en cas d\'égalité, DENSE_RANK non.',
                            syntax: 'RANK() OVER (ORDER BY col) / DENSE_RANK() OVER (ORDER BY col)',
                            options: [
                                { flag: 'RANK()', desc: 'Saute des rangs après égalité (1,1,3,4)' },
                                { flag: 'DENSE_RANK()', desc: 'Pas de saut (1,1,2,3)' },
                                { flag: 'PERCENT_RANK()', desc: 'Rang en pourcentage (0 à 1)' }
                            ],
                            examples: [
                                { code: 'SELECT nom, score,\n  RANK() OVER (ORDER BY score DESC) AS classement\nFROM joueurs', desc: 'Classement des joueurs' },
                                { code: 'SELECT nom, ventes,\n  RANK() OVER (ORDER BY ventes DESC) AS rang,\n  DENSE_RANK() OVER (ORDER BY ventes DESC) AS rang_dense\nFROM vendeurs', desc: 'Comparaison RANK vs DENSE_RANK' },
                                { code: 'SELECT departement, nom, salaire,\n  RANK() OVER (\n    PARTITION BY departement\n    ORDER BY salaire DESC\n  ) AS rang_dept\nFROM employes', desc: 'Classement par département' }
                            ],
                            tips: ['DENSE_RANK est souvent préféré pour les tops (pas de saut)', 'Avec égalité : RANK=1,1,3 | DENSE_RANK=1,1,2 | ROW_NUMBER=1,2,3'],
                            warnings: []
                        }
                    },
                    {
                        cmd: 'Diviser en groupes égaux',
                        desc: 'NTILE(n) pour quartiles, déciles',
                        details: {
                            explanation: 'NTILE(n) divise les lignes en n groupes de taille égale (ou presque égale si pas divisible).',
                            syntax: 'NTILE(n) OVER (ORDER BY col)',
                            options: [
                                { flag: 'NTILE(4)', desc: 'Quartiles (4 groupes)' },
                                { flag: 'NTILE(10)', desc: 'Déciles (10 groupes)' },
                                { flag: 'NTILE(100)', desc: 'Percentiles' }
                            ],
                            examples: [
                                { code: 'SELECT nom, salaire,\n  NTILE(4) OVER (ORDER BY salaire) AS quartile\nFROM employes', desc: 'Diviser en quartiles de salaire' },
                                { code: 'SELECT nom, score,\n  NTILE(10) OVER (ORDER BY score DESC) AS decile\nFROM etudiants', desc: 'Top 10%, 20%, etc.' },
                                { code: 'SELECT nom, chiffre_affaires,\n  CASE NTILE(4) OVER (ORDER BY chiffre_affaires DESC)\n    WHEN 1 THEN \'Top 25%\'\n    WHEN 2 THEN \'25-50%\'\n    WHEN 3 THEN \'50-75%\'\n    ELSE \'Bottom 25%\'\n  END AS segment\nFROM clients', desc: 'Segmentation client' }
                            ],
                            tips: ['NTILE(4) = quartiles, NTILE(5) = quintiles', 'Utile pour la segmentation et l\'analyse'],
                            warnings: ['Si lignes non divisibles par n, certains groupes auront +1 ligne']
                        }
                    },
                    {
                        cmd: 'Calculer des totaux cumulatifs',
                        desc: 'SUM() OVER (ORDER BY)',
                        details: {
                            explanation: 'SUM avec OVER et ORDER BY calcule un total cumulatif ligne par ligne.',
                            syntax: 'SUM(col) OVER (ORDER BY col)',
                            options: [
                                { flag: 'ORDER BY', desc: 'Cumule dans cet ordre' },
                                { flag: 'PARTITION BY', desc: 'Repart de 0 pour chaque groupe' },
                                { flag: 'ROWS UNBOUNDED PRECEDING', desc: 'Depuis le début (défaut)' }
                            ],
                            examples: [
                                { code: 'SELECT date, montant,\n  SUM(montant) OVER (ORDER BY date) AS cumul\nFROM ventes', desc: 'Ventes cumulées par date' },
                                { code: 'SELECT mois, categorie, ventes,\n  SUM(ventes) OVER (\n    PARTITION BY categorie\n    ORDER BY mois\n  ) AS cumul_categorie\nFROM stats_ventes', desc: 'Cumul par catégorie' },
                                { code: 'SELECT date, montant,\n  SUM(montant) OVER (ORDER BY date) AS cumul,\n  montant * 100.0 / SUM(montant) OVER () AS pct_total\nFROM ventes', desc: 'Cumul et pourcentage du total' }
                            ],
                            tips: ['OVER () sans ORDER BY = total global sur toutes les lignes', 'Très utile pour les graphiques d\'évolution'],
                            warnings: []
                        }
                    },
                    {
                        cmd: 'Calculer des moyennes mobiles',
                        desc: 'AVG() OVER (ROWS BETWEEN)',
                        details: {
                            explanation: 'ROWS BETWEEN définit une fenêtre glissante pour calculer des moyennes mobiles ou autres agrégations.',
                            syntax: 'AVG(col) OVER (ORDER BY col ROWS BETWEEN n PRECEDING AND m FOLLOWING)',
                            options: [
                                { flag: 'n PRECEDING', desc: 'n lignes avant' },
                                { flag: 'CURRENT ROW', desc: 'Ligne actuelle' },
                                { flag: 'm FOLLOWING', desc: 'm lignes après' },
                                { flag: 'UNBOUNDED PRECEDING', desc: 'Depuis le début' }
                            ],
                            examples: [
                                { code: 'SELECT date, ventes,\n  AVG(ventes) OVER (\n    ORDER BY date\n    ROWS BETWEEN 6 PRECEDING AND CURRENT ROW\n  ) AS moyenne_7j\nFROM stats_journalieres', desc: 'Moyenne mobile sur 7 jours' },
                                { code: 'SELECT mois, chiffre_affaires,\n  AVG(chiffre_affaires) OVER (\n    ORDER BY mois\n    ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING\n  ) AS moyenne_centree\nFROM stats_mensuelles', desc: 'Moyenne centrée (2 avant, 2 après)' },
                                { code: 'SELECT date, cours,\n  AVG(cours) OVER (\n    ORDER BY date\n    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW\n  ) AS moyenne_30j\nFROM cotations', desc: 'Moyenne mobile 30 jours (bourse)' }
                            ],
                            tips: ['ROWS = lignes physiques, RANGE = valeurs logiques', 'Moyenne mobile 7 jours = 6 PRECEDING + CURRENT ROW'],
                            warnings: ['Au début, la fenêtre peut être plus petite (pas assez de lignes précédentes)']
                        }
                    }
                ]
            },
            {
                id: 'comparer',
                title: 'Comparer des Lignes',
                icon: 'fa-balance-scale',
                color: 'border-l-4 border-pink-500',
                commands: [
                    {
                        cmd: 'Comparer avec la ligne précédente',
                        desc: 'LAG() pour accéder à la ligne d\'avant',
                        details: {
                            explanation: 'LAG() accède à la valeur d\'une colonne de la ligne précédente (selon l\'ordre défini).',
                            syntax: 'LAG(col, [offset], [default]) OVER (ORDER BY col)',
                            options: [
                                { flag: 'col', desc: 'Colonne à récupérer' },
                                { flag: 'offset', desc: 'Nombre de lignes en arrière (défaut: 1)' },
                                { flag: 'default', desc: 'Valeur si pas de ligne précédente' }
                            ],
                            examples: [
                                { code: 'SELECT date, ventes,\n  LAG(ventes) OVER (ORDER BY date) AS ventes_veille\nFROM stats_journalieres', desc: 'Ventes de la veille' },
                                { code: 'SELECT date, ventes,\n  ventes - LAG(ventes) OVER (ORDER BY date) AS variation\nFROM stats_journalieres', desc: 'Variation jour après jour' },
                                { code: 'SELECT mois, chiffre_affaires,\n  LAG(chiffre_affaires, 12) OVER (ORDER BY mois) AS ca_annee_precedente\nFROM stats_mensuelles', desc: 'Même mois année précédente' }
                            ],
                            tips: ['LAG(col, 2) = 2 lignes en arrière', 'Ajoutez un default pour éviter les NULL au début'],
                            warnings: ['Première ligne = NULL (pas de précédent)']
                        }
                    },
                    {
                        cmd: 'Comparer avec la ligne suivante',
                        desc: 'LEAD() pour accéder à la ligne d\'après',
                        details: {
                            explanation: 'LEAD() accède à la valeur d\'une colonne de la ligne suivante (selon l\'ordre défini).',
                            syntax: 'LEAD(col, [offset], [default]) OVER (ORDER BY col)',
                            options: [
                                { flag: 'col', desc: 'Colonne à récupérer' },
                                { flag: 'offset', desc: 'Nombre de lignes en avant (défaut: 1)' },
                                { flag: 'default', desc: 'Valeur si pas de ligne suivante' }
                            ],
                            examples: [
                                { code: 'SELECT date, ventes,\n  LEAD(ventes) OVER (ORDER BY date) AS ventes_lendemain\nFROM stats_journalieres', desc: 'Ventes du lendemain' },
                                { code: 'SELECT nom, date_depart,\n  LEAD(date_depart) OVER (ORDER BY date_depart) - date_depart AS jours_avant_prochain\nFROM vols', desc: 'Jours jusqu\'au prochain vol' },
                                { code: 'SELECT id, evenement, timestamp,\n  LEAD(timestamp) OVER (ORDER BY timestamp) AS timestamp_suivant\nFROM logs', desc: 'Timestamp de l\'événement suivant' }
                            ],
                            tips: ['LEAD(col, 2) = 2 lignes en avant', 'Utile pour calculer des durées entre événements'],
                            warnings: ['Dernière ligne = NULL (pas de suivant)']
                        }
                    },
                    {
                        cmd: 'Obtenir la première/dernière valeur',
                        desc: 'FIRST_VALUE() et LAST_VALUE()',
                        details: {
                            explanation: 'FIRST_VALUE et LAST_VALUE retournent la première/dernière valeur d\'une fenêtre.',
                            syntax: 'FIRST_VALUE(col) OVER (ORDER BY col) / LAST_VALUE(col) OVER (...)',
                            options: [
                                { flag: 'FIRST_VALUE()', desc: 'Première valeur de la fenêtre' },
                                { flag: 'LAST_VALUE()', desc: 'Dernière valeur de la fenêtre' },
                                { flag: 'ROWS BETWEEN ... AND UNBOUNDED FOLLOWING', desc: 'Pour LAST_VALUE correct' }
                            ],
                            examples: [
                                { code: 'SELECT nom, salaire,\n  FIRST_VALUE(nom) OVER (ORDER BY salaire DESC) AS top_salaire\nFROM employes', desc: 'Nom du mieux payé' },
                                { code: 'SELECT categorie, nom, prix,\n  FIRST_VALUE(nom) OVER (\n    PARTITION BY categorie\n    ORDER BY prix DESC\n  ) AS plus_cher_categorie\nFROM produits', desc: 'Produit le plus cher par catégorie' },
                                { code: 'SELECT date, cours,\n  cours - FIRST_VALUE(cours) OVER (ORDER BY date) AS variation_depuis_debut\nFROM cotations', desc: 'Variation depuis le premier jour' }
                            ],
                            tips: ['FIRST_VALUE est souvent plus intuitif que LAST_VALUE', 'LAST_VALUE nécessite ROWS BETWEEN ... UNBOUNDED FOLLOWING'],
                            warnings: ['LAST_VALUE par défaut ne prend que jusqu\'à la ligne courante']
                        }
                    },
                    {
                        cmd: 'Calculer la variation période à période',
                        desc: 'LAG + calcul de différence/pourcentage',
                        details: {
                            explanation: 'Combine LAG avec des calculs pour obtenir des variations absolues ou en pourcentage.',
                            syntax: '(col - LAG(col)) / LAG(col) * 100 AS variation_pct',
                            options: [
                                { flag: 'Variation absolue', desc: 'col - LAG(col)' },
                                { flag: 'Variation %', desc: '(col - LAG(col)) / LAG(col) * 100' },
                                { flag: 'YoY (Year over Year)', desc: 'LAG(col, 12) pour données mensuelles' }
                            ],
                            examples: [
                                { code: 'SELECT date, ventes,\n  ventes - LAG(ventes) OVER (ORDER BY date) AS variation,\n  ROUND((ventes - LAG(ventes) OVER (ORDER BY date)) * 100.0 /\n    LAG(ventes) OVER (ORDER BY date), 2) AS variation_pct\nFROM stats_journalieres', desc: 'Variation absolue et pourcentage' },
                                { code: 'SELECT mois, ca,\n  LAG(ca, 12) OVER (ORDER BY mois) AS ca_n1,\n  ROUND((ca - LAG(ca, 12) OVER (ORDER BY mois)) * 100.0 /\n    LAG(ca, 12) OVER (ORDER BY mois), 2) AS croissance_yoy\nFROM stats_mensuelles', desc: 'Croissance année sur année (YoY)' },
                                { code: 'SELECT date, cours,\n  ROUND((cours - LAG(cours) OVER (ORDER BY date)) * 100.0 /\n    LAG(cours) OVER (ORDER BY date), 2) AS variation_pct,\n  CASE\n    WHEN cours > LAG(cours) OVER (ORDER BY date) THEN \'↑\'\n    WHEN cours < LAG(cours) OVER (ORDER BY date) THEN \'↓\'\n    ELSE \'→\'\n  END AS tendance\nFROM cotations', desc: 'Variation avec indicateur de tendance' }
                            ],
                            tips: ['Utilisez NULLIF pour éviter la division par zéro', 'ROUND pour limiter les décimales'],
                            warnings: ['La première ligne a des NULL (pas de période précédente)']
                        }
                    }
                ]
            },
            {
                id: 'detecter',
                title: 'Détecter des Anomalies',
                icon: 'fa-magnifying-glass',
                color: 'border-l-4 border-red-500',
                commands: [
                    {
                        cmd: 'Trouver les doublons',
                        desc: 'GROUP BY + HAVING COUNT > 1',
                        details: {
                            explanation: 'Identifie les valeurs qui apparaissent plusieurs fois dans une ou plusieurs colonnes.',
                            syntax: 'SELECT col, COUNT(*) FROM table GROUP BY col HAVING COUNT(*) > 1',
                            options: [
                                { flag: 'GROUP BY col', desc: 'Groupe par la colonne à vérifier' },
                                { flag: 'HAVING COUNT(*) > 1', desc: 'Garde seulement les doublons' }
                            ],
                            examples: [
                                { code: 'SELECT email, COUNT(*) AS nb\nFROM clients\nGROUP BY email\nHAVING COUNT(*) > 1', desc: 'Emails en doublon' },
                                { code: 'SELECT nom, prenom, date_naissance, COUNT(*) AS nb\nFROM personnes\nGROUP BY nom, prenom, date_naissance\nHAVING COUNT(*) > 1', desc: 'Doublons sur plusieurs colonnes' },
                                { code: 'WITH doublons AS (\n  SELECT email FROM clients\n  GROUP BY email HAVING COUNT(*) > 1\n)\nSELECT c.* FROM clients c\nJOIN doublons d ON c.email = d.email\nORDER BY c.email', desc: 'Voir toutes les lignes en doublon' }
                            ],
                            tips: ['Utilisez un CTE pour voir les lignes complètes', 'ROW_NUMBER peut aider à identifier le "premier" de chaque groupe'],
                            warnings: []
                        }
                    },
                    {
                        cmd: 'Trouver les orphelins',
                        desc: 'LEFT JOIN WHERE IS NULL',
                        details: {
                            explanation: 'Trouve les lignes d\'une table qui n\'ont pas de correspondance dans une autre table (clé étrangère invalide).',
                            syntax: 'SELECT a.* FROM table1 a LEFT JOIN table2 b ON a.fk = b.pk WHERE b.pk IS NULL',
                            options: [
                                { flag: 'LEFT JOIN', desc: 'Garde toutes les lignes de gauche' },
                                { flag: 'WHERE IS NULL', desc: 'Filtre celles sans correspondance' }
                            ],
                            examples: [
                                { code: 'SELECT c.* FROM commandes c\nLEFT JOIN clients cl ON c.client_id = cl.id\nWHERE cl.id IS NULL', desc: 'Commandes avec client inexistant' },
                                { code: 'SELECT p.* FROM produits p\nLEFT JOIN categories cat ON p.categorie_id = cat.id\nWHERE cat.id IS NULL', desc: 'Produits avec catégorie invalide' },
                                { code: 'SELECT e.* FROM employes e\nLEFT JOIN employes m ON e.manager_id = m.id\nWHERE e.manager_id IS NOT NULL\nAND m.id IS NULL', desc: 'Employés avec manager inexistant' }
                            ],
                            tips: ['Technique classique pour vérifier l\'intégrité référentielle', 'NOT EXISTS est une alternative équivalente'],
                            warnings: ['Distinguez IS NULL (pas de correspondance) de valeur NULL dans la colonne FK']
                        }
                    },
                    {
                        cmd: 'Trouver les valeurs manquantes',
                        desc: 'Séquences et données attendues',
                        details: {
                            explanation: 'Identifie les valeurs manquantes dans une séquence (dates, numéros) ou par rapport à un référentiel.',
                            syntax: 'SELECT * FROM reference WHERE NOT EXISTS (...)',
                            options: [
                                { flag: 'NOT EXISTS', desc: 'Valeurs du référentiel absentes des données' },
                                { flag: 'NOT IN', desc: 'Alternative (attention aux NULL)' },
                                { flag: 'EXCEPT', desc: 'Différence ensembliste' }
                            ],
                            examples: [
                                { code: 'WITH dates AS (\n  SELECT generate_series(\n    \'2024-01-01\'::date,\n    \'2024-12-31\'::date,\n    \'1 day\'::interval\n  )::date AS date\n)\nSELECT d.date FROM dates d\nLEFT JOIN ventes v ON d.date = v.date\nWHERE v.date IS NULL', desc: 'Jours sans vente (PostgreSQL)' },
                                { code: 'SELECT p.nom FROM produits p\nWHERE NOT EXISTS (\n  SELECT 1 FROM ventes v\n  WHERE v.produit_id = p.id\n  AND v.date >= \'2024-01-01\'\n)', desc: 'Produits sans vente en 2024' },
                                { code: 'SELECT ville FROM villes_cibles\nEXCEPT\nSELECT DISTINCT ville FROM clients', desc: 'Villes cibles sans client' }
                            ],
                            tips: ['Créez une table de référence ou utilisez generate_series', 'EXCEPT est très lisible mais moins flexible'],
                            warnings: ['NOT IN avec des NULL peut donner des résultats inattendus']
                        }
                    },
                    {
                        cmd: 'Identifier les valeurs extrêmes',
                        desc: 'Outliers avec statistiques',
                        details: {
                            explanation: 'Détecte les valeurs anormalement hautes ou basses par rapport à la distribution.',
                            syntax: 'WHERE col > AVG(col) + n * STDDEV(col)',
                            options: [
                                { flag: 'AVG + n*STDDEV', desc: 'Écart-type (n=2 ou 3)' },
                                { flag: 'Percentiles', desc: 'En dehors de P1-P99' },
                                { flag: 'IQR', desc: 'Méthode des quartiles' }
                            ],
                            examples: [
                                { code: 'WITH stats AS (\n  SELECT AVG(montant) AS moy, STDDEV(montant) AS std\n  FROM commandes\n)\nSELECT c.* FROM commandes c, stats s\nWHERE c.montant > s.moy + 3 * s.std\n   OR c.montant < s.moy - 3 * s.std', desc: 'Outliers à 3 écarts-types' },
                                { code: 'WITH quartiles AS (\n  SELECT\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY prix) AS q1,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY prix) AS q3\n  FROM produits\n)\nSELECT p.* FROM produits p, quartiles q\nWHERE p.prix < q.q1 - 1.5 * (q.q3 - q.q1)\n   OR p.prix > q.q3 + 1.5 * (q.q3 - q.q1)', desc: 'Outliers méthode IQR' },
                                { code: 'SELECT * FROM transactions\nWHERE montant > (\n  SELECT PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY montant)\n  FROM transactions\n)', desc: 'Top 1% des montants' }
                            ],
                            tips: ['3 écarts-types = environ 0.3% des valeurs normales', 'La méthode IQR est plus robuste aux distributions asymétriques'],
                            warnings: ['Ces méthodes supposent une distribution relativement normale']
                        }
                    },
                    {
                        cmd: 'Vérifier l\'intégrité référentielle',
                        desc: 'Cohérence des clés étrangères',
                        details: {
                            explanation: 'Vérifie que toutes les clés étrangères pointent vers des enregistrements existants.',
                            syntax: 'SELECT ... LEFT JOIN ... WHERE pk IS NULL',
                            options: [
                                { flag: 'LEFT JOIN + IS NULL', desc: 'Trouve les FK invalides' },
                                { flag: 'NOT EXISTS', desc: 'Alternative équivalente' }
                            ],
                            examples: [
                                { code: '-- Script de vérification complet\nSELECT \'commandes.client_id\' AS relation, COUNT(*) AS orphelins\nFROM commandes c\nLEFT JOIN clients cl ON c.client_id = cl.id\nWHERE cl.id IS NULL\nUNION ALL\nSELECT \'produits.categorie_id\', COUNT(*)\nFROM produits p\nLEFT JOIN categories cat ON p.categorie_id = cat.id\nWHERE cat.id IS NULL', desc: 'Vérifier plusieurs relations' },
                                { code: 'SELECT\n  \'clients sans commande\' AS check,\n  COUNT(*) AS nb\nFROM clients c\nWHERE NOT EXISTS (\n  SELECT 1 FROM commandes o WHERE o.client_id = c.id\n)\nUNION ALL\nSELECT\n  \'produits sans vente\',\n  COUNT(*)\nFROM produits p\nWHERE NOT EXISTS (\n  SELECT 1 FROM ventes v WHERE v.produit_id = p.id\n)', desc: 'Données inutilisées' },
                                { code: 'SELECT DISTINCT client_id\nFROM commandes\nWHERE client_id NOT IN (\n  SELECT id FROM clients WHERE id IS NOT NULL\n)', desc: 'IDs clients invalides (avec NOT IN)' }
                            ],
                            tips: ['Exécutez régulièrement ces vérifications', 'Utilisez des contraintes FOREIGN KEY pour prévenir'],
                            warnings: ['NOT IN avec NULL peut exclure tous les résultats']
                        }
                    }
                ]
            },
            {
                id: 'modifier',
                title: 'Modifier des Données',
                icon: 'fa-edit',
                color: 'border-l-4 border-amber-500',
                commands: [
                    {
                        cmd: 'Insérer des données',
                        desc: 'INSERT INTO avec VALUES ou SELECT',
                        details: {
                            explanation: 'INSERT ajoute de nouvelles lignes dans une table, soit avec des valeurs explicites, soit depuis une autre requête.',
                            syntax: 'INSERT INTO table (cols) VALUES (vals) / INSERT INTO table SELECT ...',
                            options: [
                                { flag: 'VALUES', desc: 'Valeurs explicites' },
                                { flag: 'SELECT', desc: 'Depuis une requête' },
                                { flag: 'DEFAULT', desc: 'Utilise la valeur par défaut' },
                                { flag: 'RETURNING', desc: 'PostgreSQL : retourne les lignes insérées' }
                            ],
                            examples: [
                                { code: 'INSERT INTO clients (nom, email, ville)\nVALUES (\'Dupont\', \'dupont@email.com\', \'Paris\')', desc: 'Insertion simple' },
                                { code: 'INSERT INTO clients (nom, email, ville)\nVALUES\n  (\'Martin\', \'martin@email.com\', \'Lyon\'),\n  (\'Bernard\', \'bernard@email.com\', \'Marseille\')', desc: 'Insertion multiple' },
                                { code: 'INSERT INTO archive_clients (id, nom, email)\nSELECT id, nom, email FROM clients\nWHERE actif = false', desc: 'Insertion depuis SELECT' },
                                { code: 'INSERT INTO commandes (client_id, date, montant)\nVALUES (1, CURRENT_DATE, 100.00)\nRETURNING id, date', desc: 'PostgreSQL : récupérer l\'ID généré' }
                            ],
                            tips: ['Spécifiez toujours les colonnes pour plus de clarté', 'RETURNING évite un SELECT supplémentaire'],
                            warnings: ['Vérifiez les contraintes (NOT NULL, UNIQUE, FK) avant l\'insertion']
                        }
                    },
                    {
                        cmd: 'Mettre à jour des données',
                        desc: 'UPDATE SET WHERE',
                        details: {
                            explanation: 'UPDATE modifie les valeurs de colonnes existantes. WHERE est essentiel pour cibler les bonnes lignes.',
                            syntax: 'UPDATE table SET col = val WHERE condition',
                            options: [
                                { flag: 'SET col = val', desc: 'Nouvelle valeur' },
                                { flag: 'SET col = col + 1', desc: 'Valeur calculée' },
                                { flag: 'WHERE', desc: 'Condition de mise à jour' },
                                { flag: 'FROM', desc: 'PostgreSQL : jointure pour UPDATE' }
                            ],
                            examples: [
                                { code: 'UPDATE clients\nSET email = \'nouveau@email.com\'\nWHERE id = 123', desc: 'Mise à jour simple' },
                                { code: 'UPDATE produits\nSET prix = prix * 1.10,\n    date_maj = CURRENT_TIMESTAMP\nWHERE categorie = \'Tech\'', desc: 'Augmentation de 10%' },
                                { code: 'UPDATE commandes c\nSET statut = \'livré\'\nFROM livraisons l\nWHERE c.id = l.commande_id\nAND l.date_livraison IS NOT NULL', desc: 'PostgreSQL : UPDATE avec jointure' },
                                { code: 'UPDATE clients\nSET segment = CASE\n  WHEN total_achats > 1000 THEN \'Gold\'\n  WHEN total_achats > 500 THEN \'Silver\'\n  ELSE \'Bronze\'\nEND', desc: 'Mise à jour conditionnelle' }
                            ],
                            tips: ['Testez d\'abord avec SELECT pour vérifier les lignes ciblées', 'Utilisez une transaction pour pouvoir annuler'],
                            warnings: ['UPDATE sans WHERE modifie TOUTES les lignes !']
                        }
                    },
                    {
                        cmd: 'Supprimer des données',
                        desc: 'DELETE FROM WHERE et TRUNCATE',
                        details: {
                            explanation: 'DELETE supprime des lignes selon une condition. TRUNCATE vide une table entière plus rapidement.',
                            syntax: 'DELETE FROM table WHERE condition / TRUNCATE TABLE table',
                            options: [
                                { flag: 'DELETE FROM', desc: 'Suppression avec condition' },
                                { flag: 'TRUNCATE TABLE', desc: 'Vide toute la table (plus rapide)' },
                                { flag: 'CASCADE', desc: 'Supprime aussi les lignes dépendantes' }
                            ],
                            examples: [
                                { code: 'DELETE FROM clients\nWHERE derniere_connexion < \'2020-01-01\'', desc: 'Supprimer les clients inactifs' },
                                { code: 'DELETE FROM commandes\nWHERE statut = \'annulé\'\nAND date < CURRENT_DATE - INTERVAL \'1 year\'', desc: 'Supprimer vieilles commandes annulées' },
                                { code: 'TRUNCATE TABLE logs', desc: 'Vider la table des logs' },
                                { code: 'DELETE FROM produits p\nUSING categories c\nWHERE p.categorie_id = c.id\nAND c.nom = \'Obsolète\'', desc: 'PostgreSQL : DELETE avec jointure' }
                            ],
                            tips: ['TRUNCATE est plus rapide mais ne peut pas être annulé facilement', 'Testez d\'abord avec SELECT COUNT(*)'],
                            warnings: ['DELETE sans WHERE supprime TOUT !', 'TRUNCATE réinitialise les auto-increment']
                        }
                    },
                    {
                        cmd: 'Insérer ou mettre à jour',
                        desc: 'MERGE, ON CONFLICT, UPSERT',
                        details: {
                            explanation: 'Insère une ligne si elle n\'existe pas, sinon la met à jour. La syntaxe varie selon le SGBD.',
                            syntax: 'INSERT ... ON CONFLICT ... DO UPDATE (PostgreSQL)',
                            options: [
                                { flag: 'ON CONFLICT DO UPDATE', desc: 'PostgreSQL : upsert' },
                                { flag: 'ON DUPLICATE KEY UPDATE', desc: 'MySQL : upsert' },
                                { flag: 'MERGE', desc: 'SQL Server, Oracle : upsert complet' },
                                { flag: 'REPLACE INTO', desc: 'MySQL : supprime puis insère' }
                            ],
                            examples: [
                                { code: 'INSERT INTO produits (code, nom, prix)\nVALUES (\'ABC123\', \'Produit A\', 29.99)\nON CONFLICT (code)\nDO UPDATE SET\n  nom = EXCLUDED.nom,\n  prix = EXCLUDED.prix', desc: 'PostgreSQL : upsert sur code unique' },
                                { code: 'INSERT INTO produits (code, nom, prix)\nVALUES (\'ABC123\', \'Produit A\', 29.99)\nON DUPLICATE KEY UPDATE\n  nom = VALUES(nom),\n  prix = VALUES(prix)', desc: 'MySQL : upsert' },
                                { code: 'MERGE INTO cible t\nUSING source s ON t.id = s.id\nWHEN MATCHED THEN\n  UPDATE SET t.nom = s.nom, t.prix = s.prix\nWHEN NOT MATCHED THEN\n  INSERT (id, nom, prix)\n  VALUES (s.id, s.nom, s.prix)', desc: 'SQL Server/Oracle : MERGE' }
                            ],
                            tips: ['EXCLUDED (PostgreSQL) ou VALUES() (MySQL) référence les nouvelles valeurs', 'Utile pour les imports et synchronisations'],
                            warnings: ['Nécessite une contrainte UNIQUE pour détecter les conflits']
                        }
                    }
                ]
            },
            {
                id: 'structurer',
                title: 'Gérer la Structure',
                icon: 'fa-table',
                color: 'border-l-4 border-gray-500',
                commands: [
                    {
                        cmd: 'Créer une table',
                        desc: 'CREATE TABLE avec contraintes',
                        details: {
                            explanation: 'CREATE TABLE définit une nouvelle table avec ses colonnes, types de données et contraintes.',
                            syntax: 'CREATE TABLE nom (col1 type contraintes, ...)',
                            options: [
                                { flag: 'PRIMARY KEY', desc: 'Clé primaire (unique, non null)' },
                                { flag: 'FOREIGN KEY', desc: 'Clé étrangère vers une autre table' },
                                { flag: 'NOT NULL', desc: 'Valeur obligatoire' },
                                { flag: 'UNIQUE', desc: 'Valeurs uniques' },
                                { flag: 'DEFAULT', desc: 'Valeur par défaut' },
                                { flag: 'CHECK', desc: 'Contrainte de validation' }
                            ],
                            examples: [
                                { code: 'CREATE TABLE clients (\n  id SERIAL PRIMARY KEY,\n  nom VARCHAR(100) NOT NULL,\n  email VARCHAR(255) UNIQUE,\n  date_inscription DATE DEFAULT CURRENT_DATE\n)', desc: 'Table simple avec contraintes' },
                                { code: 'CREATE TABLE commandes (\n  id SERIAL PRIMARY KEY,\n  client_id INTEGER NOT NULL,\n  montant DECIMAL(10,2) CHECK (montant > 0),\n  statut VARCHAR(20) DEFAULT \'en_attente\',\n  FOREIGN KEY (client_id) REFERENCES clients(id)\n)', desc: 'Table avec clé étrangère' },
                                { code: 'CREATE TABLE IF NOT EXISTS logs (\n  id BIGSERIAL PRIMARY KEY,\n  timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  niveau VARCHAR(10),\n  message TEXT\n)', desc: 'Créer si n\'existe pas' }
                            ],
                            tips: ['Utilisez SERIAL/BIGSERIAL (PostgreSQL) ou AUTO_INCREMENT (MySQL) pour les IDs', 'IF NOT EXISTS évite les erreurs si la table existe'],
                            warnings: ['Choisissez bien les types de données (VARCHAR vs TEXT, INTEGER vs BIGINT)']
                        }
                    },
                    {
                        cmd: 'Modifier une table',
                        desc: 'ALTER TABLE ADD/DROP/MODIFY',
                        details: {
                            explanation: 'ALTER TABLE modifie la structure d\'une table existante : ajoute, supprime ou modifie des colonnes.',
                            syntax: 'ALTER TABLE nom ADD/DROP/ALTER COLUMN ...',
                            options: [
                                { flag: 'ADD COLUMN', desc: 'Ajoute une colonne' },
                                { flag: 'DROP COLUMN', desc: 'Supprime une colonne' },
                                { flag: 'ALTER COLUMN', desc: 'Modifie une colonne' },
                                { flag: 'RENAME COLUMN', desc: 'Renomme une colonne' },
                                { flag: 'ADD CONSTRAINT', desc: 'Ajoute une contrainte' }
                            ],
                            examples: [
                                { code: 'ALTER TABLE clients\nADD COLUMN telephone VARCHAR(20)', desc: 'Ajouter une colonne' },
                                { code: 'ALTER TABLE clients\nDROP COLUMN fax', desc: 'Supprimer une colonne' },
                                { code: 'ALTER TABLE clients\nALTER COLUMN email SET NOT NULL', desc: 'PostgreSQL : rendre obligatoire' },
                                { code: 'ALTER TABLE clients\nRENAME COLUMN nom TO nom_complet', desc: 'Renommer une colonne' },
                                { code: 'ALTER TABLE commandes\nADD CONSTRAINT fk_client\nFOREIGN KEY (client_id) REFERENCES clients(id)', desc: 'Ajouter une clé étrangère' }
                            ],
                            tips: ['Faites un backup avant de modifier la structure', 'Ajoutez les colonnes avec DEFAULT pour éviter les NULL'],
                            warnings: ['DROP COLUMN est irréversible', 'Modifier le type peut échouer si données incompatibles']
                        }
                    },
                    {
                        cmd: 'Supprimer une table',
                        desc: 'DROP TABLE et TRUNCATE',
                        details: {
                            explanation: 'DROP TABLE supprime complètement une table. TRUNCATE vide son contenu mais garde la structure.',
                            syntax: 'DROP TABLE [IF EXISTS] nom [CASCADE]',
                            options: [
                                { flag: 'DROP TABLE', desc: 'Supprime table et données' },
                                { flag: 'IF EXISTS', desc: 'Pas d\'erreur si n\'existe pas' },
                                { flag: 'CASCADE', desc: 'Supprime aussi les dépendances' },
                                { flag: 'TRUNCATE', desc: 'Vide la table, garde la structure' }
                            ],
                            examples: [
                                { code: 'DROP TABLE IF EXISTS temp_import', desc: 'Supprimer si existe' },
                                { code: 'DROP TABLE commandes CASCADE', desc: 'Supprimer avec dépendances' },
                                { code: 'TRUNCATE TABLE logs', desc: 'Vider la table' },
                                { code: 'TRUNCATE TABLE stats RESTART IDENTITY', desc: 'Vider et réinitialiser les séquences' }
                            ],
                            tips: ['IF EXISTS évite les erreurs dans les scripts', 'TRUNCATE est plus rapide que DELETE FROM'],
                            warnings: ['DROP TABLE est irréversible !', 'CASCADE peut supprimer des vues et contraintes dépendantes']
                        }
                    },
                    {
                        cmd: 'Optimiser avec des index',
                        desc: 'CREATE INDEX pour les performances',
                        details: {
                            explanation: 'Les index accélèrent les recherches (WHERE, JOIN, ORDER BY) au prix d\'un espace disque supplémentaire.',
                            syntax: 'CREATE [UNIQUE] INDEX nom ON table (colonnes)',
                            options: [
                                { flag: 'INDEX', desc: 'Index standard (B-tree)' },
                                { flag: 'UNIQUE INDEX', desc: 'Index avec contrainte d\'unicité' },
                                { flag: 'CONCURRENTLY', desc: 'PostgreSQL : sans bloquer la table' },
                                { flag: 'USING', desc: 'Type d\'index (btree, hash, gin, gist)' }
                            ],
                            examples: [
                                { code: 'CREATE INDEX idx_clients_ville\nON clients (ville)', desc: 'Index simple' },
                                { code: 'CREATE UNIQUE INDEX idx_clients_email\nON clients (email)', desc: 'Index unique (contrainte)' },
                                { code: 'CREATE INDEX idx_commandes_client_date\nON commandes (client_id, date DESC)', desc: 'Index multi-colonnes' },
                                { code: 'CREATE INDEX CONCURRENTLY idx_logs_date\nON logs (date)', desc: 'PostgreSQL : création sans blocage' },
                                { code: 'DROP INDEX IF EXISTS idx_old_index', desc: 'Supprimer un index' }
                            ],
                            tips: ['Indexez les colonnes souvent utilisées dans WHERE et JOIN', 'L\'ordre des colonnes dans un index multi-colonnes compte'],
                            warnings: ['Trop d\'index ralentit INSERT/UPDATE/DELETE', 'Les index prennent de l\'espace disque']
                        }
                    }
                ]
            }
        ];
    </script>
    <script src="../js/cheatsheet.js"></script>
</body>
</html>
